# Шпаргалка по синтаксису языка C

- [Шпаргалка по синтаксису языка C](#шпаргалка-по-синтаксису-языка-c)
  - [Имена объектов. Комментарии](#имена-объектов-комментарии)
  - [Объявление переменных. Типы данных](#объявление-переменных-типы-данных)
  - [Оператор присваивания](#оператор-присваивания)
  - [Арифметические операции](#арифметические-операции)
  - [Арифметические операции: деление](#арифметические-операции-деление)
  - [Арифметические операции: сокращенная форма](#арифметические-операции-сокращенная-форма)
  - [Битовые операции](#битовые-операции)
  - [Оператор ветвления](#оператор-ветвления)
  - [Операция сравнения и логические операции](#операция-сравнения-и-логические-операции)
  - [Оператор switch](#оператор-switch)
  - [Массивы](#массивы)
  - [Операторы цикла](#операторы-цикла)
  - [Примеры](#примеры)
  - [Объявление и вызов функций](#объявление-и-вызов-функций)
  - [Пример объявления и вызова функций](#пример-объявления-и-вызова-функций)
  - [Примеры на функции](#примеры-на-функции)
  - [Указатели](#указатели)
  - [Массивы и указатели](#массивы-и-указатели)
  - [Строки и символы](#строки-и-символы)
  - [Структуры](#структуры)
  - [Объединения](#объединения)
  - [Константы](#константы)
  - [Битовые операции](#битовые-операции-1)
  - [Препроцессор](#препроцессор)
  - [Обращение к регистрам специальных функций](#обращение-к-регистрам-специальных-функций)
    - [Способ 1](#способ-1)
    - [Способ 2](#способ-2)
    - [Способ 3](#способ-3)
  - [Обработка прерываний в Cortex-M](#обработка-прерываний-в-cortex-m)
  - [Ассемблерные вставки](#ассемблерные-вставки)

## Имена объектов. Комментарии

```c
te+st/ = 1; /* Ошибка: имена должны содержать только буквы, цифры и символ _ */
1test = 3;  /* Ошибка: имена не должны начинаться с цифры */
test = 4;   /* ОК */

/* Test и test разные объекты - регистр имеет значение */
Test = 5;
test = 6;

TestLab1 = 7;         /* ОК CamelCase */
lesson_number_1 = 8;  /* ОК snake_case */
MPEI_ER_02_13 = 2;    /* ОК SCREAMING_SNAKE_CASE */
is_valid_parameter(first_param); /* ОК */

/* Многострочный комментарий по
стандарту C */
a = a + b; // Однострочный комментарий в стиле C++
```

## Объявление переменных. Типы данных

```c
/* Объявление целочисленной
переменной со знаком
(дополнительный код со
знаком) */
int i;
i = 13;
/* Объявление беззнаковой
целочисленной переменной */
unsigned int j;
j = 0;
/* Объявление переменной
с плавающей запятой */
float a, b;
a = 10.0;
b = 20.0;
/* Объявление и инициализация
символьной переменной */
char c = 'a';
```

## Оператор присваивания

```c
/* Объявление и инициализация */
int a = 1;
int b = 2;
int tmp;

/* Обмен значений a и b */
tmp = a;
a = b;
b = tmp; /* a = 2, b = 1 */

int i, j, k;

/* Множественное присваивание */
i = j = k = 0;
```

## Арифметические операции

```c
int a = 0;
int b = 2;
int c;
/* Сложение */
c = a + b; /* c = 2 */
c = c + 2; /* c = 4 */
/* Вычитание */
c = b - a; /* c = 2 */
/* Умножение */
c = 4 * b; /* c = 8 */
/* Деление */
a = 10;
c = a / 2;   /* a = 5 */
c = a / 100; /* a = 0 */
/* Остаток от деления */
a = 13;
c = a % 10;  /* c = 3 */
```

## Арифметические операции: деление

```c
int a;

/* Целочисленное деление */
a = 1 / 2;    /* a = 0 */
a = 10 / 100; /* a = 0 */
a = 3 / 2;    /* a = 1 */
a = 11 / 2;   /* a = 5 */

float c;

/* Деление чисел с плавающей запятой */
c = 1.0 / 2.0; /* c = 0.5 */
c = 1 / 2.0;   /* c = 0.5 */
c = 1.0 / 2;   /* c = 0.5 */
c = 1 / 2;     /* c = 0.0 */
```

## Арифметические операции: сокращенная форма

```c
int i = 0;

i++; /* i = 1 */
++i; /* i = 2 */

/* Разница между префиксной и
постфиксной формой */
i = 0;
a = i++; /* a = 0, i = 1 */
a = ++i; /* a = 2, i = 2 */
i = 0;
i += 10; /* i = 10 */

a = 2;
i /= a + 3; /* i = 2 */
```

## Битовые операции

```c
/* 0xА - шестнадцатеричная форма,
   012 - восьмеричная форма,
   10 - десятичная форма */

int a = 0x88;

a = a & 0xFE; /* Сброс бита a = 0x80 */

a = a | 0x02; /* Установка бита a = 0x82 */

a = a ^ 0x01; /* Инверсия бита a = 0x83 */
a = a ^ 0x01; /* Инверсия бита a = 0x82 */

a = ~a; /* Инверсия a = 0x7D */

a = 0x01;

a = a << 2; /* Сдвиг влево a = 0x04 */
a = a >> 1; /* Сдвиг вправо a = 0x02 */
```

## Оператор ветвления

```c
/* Простая форма без {} */
if (выражение)
    оператор;

/* Простая форма с {} */
if (выражение) {
    оператор1;
    оператор2;
}

/* Проверка на четность */
if (a % 2 == 0)
    cnt++; // Одно утверждение


/* Простая форма с {} */
if (is_ready) {
    timeout = 100;
    status = OK;
}

/* Полная форма */
if (выражение) {
    оператор1;
}
else {
    оператор2;
}

if (выражение1) {
    оператор1;
}
else if (выражение2) {
    оператор2;
}
else {
    оператор3;
}

if (voltage < 100) {
    status = OK;
}
else {
    status = FAIL;
}

if (cmd == RUN) {
    run();
}
else if (cmd == STOP) {
    stop();
}
else {
    idle();
}
```

## Операция сравнения и логические операции

```c
if (a < 0) {
    ...
}

if ((status & 0x01) == 0) {
    ...
}

if ((a > 0) && (a != 10)) {
    ...
}

if (!is_stopped) {

}
```

## Оператор switch

```c
switch (выражение) {
    case константа1:
        оператор1;
        оператор2;
        break;
    case константа2:
        оператор3;
        break;
    case константа3:
    case константа4:
        оператор4;
        break;
    default: // необязательно
        оператор5;
}

switch (cmd) {
    case CMD_RUN:
        set_pwm(100);
        run();
        break;
    case CMD_STOP:
        stop();
        break;
    case CMD_IDLE:
    case CMD_RESET:
        idle();
        break;
    default:
        error();
}
```

## Массивы

```c
/* Объявление массива без инициализации */
int arr[10];

arr[0] = 1;  /* Первый элемент */
arr[1] = 4;  /* Второй элемент */
arr[9] = 99; /* Последний элемент */

/* Компилятор не проверяет выход за пределы */
arr[-1] = 100; /* Ошибка при исполнении */
arr[10] = 100; /* Ошибка при исполнении */

/* Объявление массива с инициализацией */
char letters[] = {'x', 'y', 'z'};


/* Многомерные массивы */
int marr[10][10];

marr[0][0] = 13; /* Первый элемент */
marr[0][1] = 27;
marr[0][9] = 43;
marr[1][0] = 69;
marr[9][8] = 87;
marr[9][9] = 91; /* Последний элемент */
```

## Операторы цикла

```c
/* Цикл while */
while (выражение) {
    оператор;
}

/* Цикл do-while */
do {
    оператор;
} while (выражение);

/* Цикл for */
for (выраж1; выраж2; выраж3) {
    оператор;
}


while (i < 10) {
    a[i] = i;
    i++;
}

do {
    spi_send_byte(cmd);
    status = spi_get_status();
} while (status != SPI_OK);

/* "Зануление" массива */
for (i = 0; i < n; i++) {
    a[i] = 0;
}

/* Бесконечный цикл */
for(;;);
while(1);

/* Оператор break */
while (выражение1) {
    ...
    if (выражение2)
        break;
    ...
}


/* Оператор continue */
while (выражение1) {
    ...
    if (выражение2)
        continue;
    ...
}
```

## Примеры

```c
/* Проверка наличия элемента в массиве */
int is_found = 0, i = 0;
while (i < n) {
    if (a[i] == target) {
        is_found = 1;
        break;
    }
    i++;
}

/* Обработка только положительных элементов */
int i;
for (i = 0; i < n; i++) {
    if (a[i] < 0)
        continue;
    ...
}
```

## Объявление и вызов функций

```c
/* Объявление функций */
тип-возвр-значения имя-функции(аргументы)
{
    объявления
    операторы
}

/* Вызов функций */
переменная = имя-функции(аргументы);


int add_two(int n)
{
    int tmp = 0;

    tmp = n + 2;
    return tmp;
}

a = add_two(2);
```

## Пример объявления и вызова функций

```c
/* Абсолютное значение числа */
int abs(int n)
{
    if (n < 0)
        return -n;
    else
        return n;
}
/* Поиск максимального элемента в массиве */
int arr_max(int a[], int n)
{
    int max = a[0];
    for (int i = 1; i < n; i++)
        if (a[i] > max)
            max = a[i];
    return max;
}


/* Включить светодиод */
void led_on()
{
    PORTC |= 0x01;
}

/* Вызов функций */
void main()
{
    int c;
    c = abs(-10); /* c = 10 */

    int arr[5] = {4, 3, 1, 7, 5};

    с = arr_max(arr, 5); /* с = 7 */
    led_on();
}
```

## Примеры на функции

```c
/* Обратить порядок элементов в массиве */
void reverse(char a[], int n)
{
    int i, j, tmp;
    for (i = 0, j = n - 1; i < j; i++, j--){
        tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }
    return; /* Необязательно */
}

/* Вызов функций */
void main()
{
    char arr[5] = {4, 3, 1, 7, 5};
    char len = 5;

    reverse(arr, len);
    /* arr = {5, 7, 1, 3, 4} */
    int i;
    for (i = 0; i < len; i++){
        printf(“%d “, arr[i]);
    }
}
```

## Указатели

```c
/* Объявление переменных и массива */
int x = 1, y = 2, z[10];
/* Объявление указателя */
int *p;

p = &x;/* p - адрес переменной x
или p - указывает на x */

/* Разыменование *p */
y = *p; /* *p = x = 1 -> y = 1 */
*p = 0; /* x = 0 */

p = &z[0];/*p - указывает на z[0]*/
*p = 100;/* z[0] = 100 */
```

## Массивы и указатели

```c
/* Объявление массива */
int a[10];
/* Объявление указателя */
int *pa;

pa = &a[0]; /* Указатель на a[0] */
pa = a; /* Эквивалентно pa = &a[0] */

/* a[i] эквивалентно *(pa + i) */
*pa = 0; /* a[0] = 0 */
*(pa + 2) = 2; /* a[2] = 2 */
```

## Строки и символы

```c
/* Объявление и инициализация строки */
char msg[] = "Hello\r\n";
/* Объявление и инициализация символа */
char ch = 'a';
```

## Структуры

```c
/* Объявление структуры */
struct point {
    int x;
    int y;
};

/* Объявление переменной pt1 типа point */
struct point pt1;

/* Инициализация полей структуры */
pt1.x = 22;
pt1.y = 7;

/* Инициализация структуры */
struct point pt2 = {-10, 0};
```

## Объединения

```c
/* Объявление объединения */
union {
    int word;
    short hword[2];
    char byte[4];
} u;

u.word = 0x12345678;

short lo_hword = u.hword[0];/* lo_hword = 0x5678 */
char hi_byte = u.byte[3];/* hi_byte = 0x12 */
```

## Константы

```c
/* Макроопределения */
#define MAXLEN 100
char msg[MAXLEN + 1];

#define TRUE 1
#define FALSE 0

if (res == TRUE)
    ...

/* Перечисления */
enum month {JAN = 1, FEB, MAR, APR,
MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC};
/* FEB = 2, MAR = 3, ...*/

enum boolean {FALSE = 0, TRUE};/* TRUE = 1 */
```

## Битовые операции

```c
/* Битовые поля */
struct {
    unsigned int enable : 1;
    unsigned int test: 1;
    unsigned int err_code: 3;
} state_flags;

state_flags.enable = 1;
state_flags.test = 0;
state_flags.err_code = 4;

unsigned int flags;

flags = flags | 1; /* Установить бит 0 */
flags |= 1; /* То же самое в сокращенной форме */

flags = flags & ~2;/* Сбросить бит 1 */
flags &= ~2;/* То же самое в сокращенной форме */

flags |= (1 << 3); /* Установить бит 3 */
flags &= ~(1 << 4); /* Сбросить бит 4 */
```

## Препроцессор

```c
/* Макроопределения */
#define ARR_SIZE 10
#define TRUE 1
#define FALSE 0
#define STEP 100

/* Подключение файлов */
#include "adc.h"
#include <stdio.h>


#define DEBUG

/* Условная компиляция */
#ifdef DEBUG
...
#endif
```

## Обращение к регистрам специальных функций

### Способ 1

```c
#define GPIOC_ODR       (*((volatile unsigned int *)(0x48000800 + 0x14)))
...
GPIOC_ODR = GPIOC_ODR | 0x00000001;/* Установить 1 в PC0 */
```

### Способ 2

```c
#include <stm32f0xx.h>
...
GPIOC->ODR = GPIOC->ODR | 0x00000001;/* Установить 1 в PC0 */
```

### Способ 3

```c
#include <stm32f0xx_hal.h>
...
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET); /* Установить 1 в PC0 */
```

## Обработка прерываний в Cortex-M

В файле `startup_stm32f072xb.s` ищем название вектора обработки прерывания:

```asm
DCD     ADC1_COMP_IRQHandler           ; ADC1, COMP1 and COMP2
DCD     TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation
DCD     TIM1_CC_IRQHandler             ; TIM1 Capture Compare
DCD     TIM2_IRQHandler                ; TIM2
DCD     TIM3_IRQHandler                ; TIM3
```

В файлах разработчика, например в main.c, создаем функцию с этим названием:

```c
/* Подпрограмма обработчик прерывания по ADC1 */
void ADC1_COMP_IRQHandler(void)
{
    ...
}
/* Подпрограмма обработчик прерывания по TIM2 */
void TIM2_IRQHandler(void)
{
    ...
}
```

## Ассемблерные вставки

```c
/* Для IDE Keil uVision */
__asm void add(int x1, int x2, int x3)
{
    ADDS R0, R0, R1
    ADDS R0, R0, R2
    BX LR
}

int swap32(int i)
{
    int res;
    __asm {
        REVSH res, i
    }
    return res;
}

__asm("WFI"); /* Выполнение одной команды */
```
